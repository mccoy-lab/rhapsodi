library(tidyverse)
library(pbapply)
library(pbmcapply)
library(HMM)

# not sure what to do twith this information 
#don't need #args <- commandArgs(trailingOnly = TRUE)
#input_file <- # file path 
sampleName <- "NC12" # pull from file path 
chrom <- 10 # pull from file path 
outDir <- "~/Users/saracarioscia/mccoy-lab/transmission-distortion"
seqError <- 0.005
hapProb <- 1 - seqError
#don't need #threads <- as.integer(args[6])
#window_length <- as.integer(args[7]) #2500 default, if error raised -- retry with 1000 and 5000 also
window_length <- 2500

# custom function to get the data into the right form 
# but note the format of the data necessary to be input to the function 
# load the data

input_file <- "/Users/saracarioscia/mccoy-lab/transmission-distortion/nc12ab_goodcellsreplicatebcs_filteredhetsnps_10.cellsbyrow.txt"

dt <- read_delim(input_file, delim = "\t") %>%
  pivot_wider(., names_from = "cell", values_from = "gt") %>%
  arrange(., pos) %>%
  as.data.frame()

# remove the first column (positions)
positions <- dt[, 1]
dt <- dt[,-1]

# What's the word for the v input? 
# this function gets the mode of a vector after removing the NAs
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv <- uniqv[!is.na(uniqv)]
  uniqv[which.max(tabulate(match(v, uniqv)))]
}

# this function replaces 0s with 1s and 1s with 0s in a data frame
invertBits <- function(dataframe) {
  dataframe[dataframe == 0] <- -1
  dataframe[dataframe == 1] <- 0
  dataframe[dataframe == -1] <- 1
  return(dataframe)
}

# overlapping window function from https://stackoverflow.com/questions/8872376/split-vector-with-overlapping-samples-in-r
# what is vec in our code
splitWithOverlap <- function(vec, seg_length, overlap) {
  starts = seq(1, length(vec), by=seg_length - overlap)
  ends   = starts + seg_length - 1
  ends[ends > length(vec)] = length(vec)
  lapply(1:length(starts), function(i) vec[starts[i]:ends[i]])
}

# inputs could be: window_length, positions (aka 1st column of the input file)
# use overlaps of window length/2
make_windows <- function(positions, window_length) {
  windows <- splitWithOverlap(rank(positions), window_length, overlap = window_length / 2)
  return(windows)
}

# function to reconstruct parental haplotypes
reconstruct_hap <- function(input_dt, input_positions, window_indices) {
  window_start <- min(window_indices)
  window_end <- max(window_indices)
  positions_for_window <- input_positions[window_start:window_end]
  # compute a distance matrix
  d <- dist(t(as.matrix(input_dt)[window_start:window_end,]), method = "binary")
  # plut in 0.5 for any NA entries of the distance matrix
  d[is.na(d)] <- 0.5
  # cluster the distance matrix
  tree <- hclust(d, method = "ward.D2")
  # plot(tree, cex = 0.1) # uncomment to plot
  # cut the tree generated by clustering into two groups (haplotypes)
  haplotypes <- cutree(tree, k=2)
  # get the names of the sperm cells falling into the two groups
  h1_gamete <- names(haplotypes[haplotypes == 1])
  h2_gamete <- names(haplotypes[haplotypes == 2])
  # reconstruct the original haplotypes by majority vote after inverting the opposite haplotype
  h1_inferred <- unname(apply(cbind(input_dt[window_start:window_end, h1_gamete],
                                    invertBits(input_dt[window_start:window_end, h2_gamete])),
                              1, function(x) getmode(x)))
  h2_inferred <- unname(apply(cbind(input_dt[window_start:window_end, h2_gamete],
                                    invertBits(input_dt[window_start:window_end, h1_gamete])),
                              1, function(x) getmode(x)))
  return(tibble(index = window_indices, pos = positions_for_window, h1 = h1_inferred))
}

# name this a new function? `infer_haplotypes`
# infer the haplotypes within the overlapping windows
infer_haplotypes <- function(windows, dt, positions) {
  inferred_haplotypes <- pbmclapply(1:length(windows), 
                                    function(x) reconstruct_hap(dt, positions, windows[[x]]))
}

# make this a new function? `stitch_haplotypes`
# stitch together the haplotypes
stitch_haplotypes <- function(inferred_haplotypes, windows) {
  initial_haplotype <- inferred_haplotypes[[1]]
  for (hap_window in 2:length(windows)) {
    overlap_haps <- merge(initial_haplotype, inferred_haplotypes[[hap_window]], by = "index")
    overlap_haps_complete <- merge(initial_haplotype, inferred_haplotypes[[hap_window]], by = "index", all = TRUE)
    mean_concordance <- mean(overlap_haps$h1.x == overlap_haps$h1.y)
    if (mean_concordance < 0.1) {
      overlap_haps_complete$h1.y <- invertBits(overlap_haps_complete$h1.y)
    } else if (mean_concordance < 0.9) {
      error(paste0("Haplotypes within overlapping windows are too discordant to merge. Mean: ", mean_concordance))
    }
    initial_haplotype <- tibble(index = overlap_haps_complete$index,
                                pos = c(overlap_haps_complete[is.na(overlap_haps_complete$pos.y),]$pos.x,
                                        overlap_haps_complete[!is.na(overlap_haps_complete$pos.x) &
                                                                !is.na(overlap_haps_complete$pos.y),]$pos.x,
                                        overlap_haps_complete[is.na(overlap_haps_complete$pos.x),]$pos.y),
                                h1 = c(overlap_haps_complete[is.na(overlap_haps_complete$pos.y),]$h1.x,
                                       overlap_haps_complete[!is.na(overlap_haps_complete$pos.x) &
                                                               !is.na(overlap_haps_complete$pos.y),]$h1.x,
                                       overlap_haps_complete[is.na(overlap_haps_complete$pos.x),]$h1.y))
  }
}


# new function - `complete_haplotypes`
complete_haplotypes <- function(initial_haplotype, h1) {
  complete_haplotypes <- initial_haplotype %>%
    mutate(h2 = invertBits(h1))
}
#build model with the above inputs
hmm <- initHMM(States = states,
               Symbols = emissions,
               transProbs = transProb,
               emissionProbs = emissProb)

# `assign_haplotype`
# Going through each sperm, if an allele (0 or 1) in a sperm matches the allele (0 or 1)
# in h1 at that position, replace the allele with "h1". Do the same for h2.
assign_haplotype <- function(complete_haplotypes, dt) {
  for (i in 1:ncol(dt)) {
    dt[i][dt[i] == complete_haplotypes$h1] <- "h1"
    dt[i][dt[i] == complete_haplotypes$h2] <- "h2"
  }
}

# Scan sperm by sperm to interpret state given emission
# First, we initialize our HMM

build_HMM <- function(complete_haplotypes, sequencing_error) {
  # set denominator for transition probability - one recombination event per chromosome
  num_snps <- nrow(complete_haplotypes)
  
  # two states
  states <- c("haplotype1", "haplotype2")
  
  # probability of state at position x+1 given state at position x   
  hap1Prob <- c(1-(1/num_snps), 1/num_snps)
  hap2Prob <- c(1/num_snps, 1-(1/num_snps))
  # Probability of transitioning at any given position 
  transProb <- matrix(c(hap1Prob, hap2Prob), 2)
  
  # Two emissions (observations): an allele from h1 or an allele from h2
  emissions <- c("h1","h2")
  
  # Prob of emitting an h1 allele, prob of emitting an h2 allele in state `haplotype1`
  h1ProbEmiss <- c((1-sequencing_error), sequencing_error)
  # Prob of emitting an h1 allele, prob of emitting an h2 allele in state `haplotype2`
  h2ProbEmiss <- c(sequencing_error, (1-sequencing_error))
  emissProb <- matrix(c(h1ProbEmiss, h2ProbEmiss), 2)
  
  #build model with the above inputs
  hmm <- initHMM(States = states,
                 Symbols = emissions,
                 transProbs = transProb,
                 emissionProbs = emissProb)
  return(hmm)
}



###### Function to run HMM on an input file
# Compute the inferred state using each sperm cell as the input
# (Input must be a vector)
# Rename sperm_dt to gamete_dt
runHMM <- function(sperm_dt, column_index) {
  original_obs <- sperm_dt[,column_index]
  inferred_state <- viterbi(hmm, na.omit(sperm_dt[, column_index]))
  original_obs[!is.na(original_obs)] <- inferred_state
  return(original_obs)
}

# make this a function `impute_gametes`
impute_gametes <- function(dt) {
  imputed_gametes <- as_tibble(do.call(cbind, pbmclapply(1:ncol(dt),
                                                       function(x) runHMM(dt, x))))
  colnames(imputed_gametes) <- colnames(dt)
}



# rename this as imputed_gametes 

# Works on our sperm! Need to make the function work on every sperm in test3
# and need to make fill up and down at the end
# rename merged_sperm as merged_gametes and rename all sperm here as gametes 
fill_NAs <- function(merged_gametes, col_index) {
  gamete_sample <- merged_gametes[,col_index] %>%
    rename(gamete = colnames(.)[1]) %>%
    mutate(gamete_up = gamete) %>%
    mutate(gamete_down = gamete) %>%
    fill(gamete_up, .direction = "up") %>%
    fill(gamete_down, .direction = "down") %>%
    mutate(is_match = (gamete_up == gamete_down)) %>%
    replace_na(list(is_match = FALSE))
  gamete_sample$gamete_imputed <- as.character(NA)
  gamete_sample[gamete_sample$is_match == TRUE,]$gamete_imputed <- gamete_sample[gamete_sample$is_match == TRUE,]$gamete_up
  #fill beginning of chromosome NA's
  first <- which(!is.na(gamete_sample$gamete_imputed))[1]
  gamete_sample$gamete_imputed[1:(first-1)] <- gamete_sample$gamete_imputed[first]
  #fill end of chromosome NA's
  gamete_sample$gamete_imputed <- rev(gamete_sample$gamete_imputed)
  first <- which(!is.na(gamete_sample$gamete_imputed))[1]
  gamete_sample$gamete_imputed[1:(first-1)] <- gamete_sample$gamete_imputed[first]
  #reverse chromosome imputation back so it faces the right way
  gamete_sample$gamete_imputed <- rev(gamete_sample$gamete_imputed)
  return(gamete_sample$gamete_imputed)
}

fill_gametes <- function(imputed_gametes, dt) {
  filled_gametes <- as_tibble(do.call(cbind, 
                                      pblapply(1:ncol(imputed_gametes),
                                               function(x) fill_NAs(imputed_gametes, x))))
  colnames(filled_gametes) <- colnames(dt)
}




#######
## not included in R package 
td_test <- function(sperm_matrix, row_index) {
  test_row <- sperm_matrix[row_index,]
  gt_vector <- unlist(test_row)[-1]
  one_count <- sum(gt_vector == "haplotype1", na.rm = TRUE)
  two_count <- sum(gt_vector == "haplotype2", na.rm = TRUE)
  p_value <- binom.test(c(one_count, two_count))$p.value
  return(c(p_value, one_count, two_count))
}

df_counts_pvals <- do.call(rbind, pbmclapply(1:nrow(filled_sperm), 
                                             function(x) td_test(filled_sperm, x))) %>%
  as_tibble() %>% 
  add_column(positions) #bind the positions vector to df_counts_pvals
colnames(df_counts_pvals) <- c("pval", "h1_count", "h2_count", "genomic_position")
filename_df <- paste0(outDir, sampleName, "_", chrom, "_pval.csv")
write_csv(df_counts_pvals, filename_df)

#find recombination spots
find_recomb_spots <- function(input_matrix, x, identities, genomic_positions){
  ident <- identities[x]
  input_tibble <- input_matrix[, x] %>%
    mutate(., index = row_number()) %>%
    mutate(., positions = genomic_positions)
  complete_cases_tibble <- input_tibble[complete.cases(input_tibble),]
  input_vec <- as.factor(complete_cases_tibble[[1]])
  switch_indices <- which(input_vec[-1] != input_vec[-length(input_vec)])
  switch_indices_input <- complete_cases_tibble[switch_indices,]$index
  crossover_start <- input_tibble[switch_indices_input,]$positions
  rev_input_tibble <- arrange(input_tibble, -index) %>%
    mutate(., index = row_number())
  complete_cases_rev_tibble <- rev_input_tibble[complete.cases(rev_input_tibble),]
  rev_input_vec <- as.factor(complete_cases_rev_tibble[[1]])
  rev_switch_indices <- which(rev_input_vec[-1] != rev_input_vec[-length(rev_input_vec)])
  rev_switch_indices_input <- complete_cases_rev_tibble[rev_switch_indices,]$index
  crossover_end <- rev(rev_input_tibble[rev_switch_indices_input,]$positions)
  recomb_spots <- tibble(Ident = ident, Genomic_start = crossover_start, Genomic_end = crossover_end)
  return(recomb_spots)
}

idents_for_csv <- paste0(paste0(sampleName, "_", chrom, "_"), colnames(filled_sperm))
recomb_spots_all <- do.call(rbind, pbmclapply(1:ncol(filled_sperm),
                                              function(x) find_recomb_spots(filled_sperm, x, idents_for_csv, positions),
                                              mc.cores=getOption("mc.cores", threads))) %>% 
  right_join(., tibble(Ident = idents_for_csv), by = "Ident")
filename_rs <- paste0(outDir, sampleName, "_", chrom, "_recombination_locs.csv")
write_csv(recomb_spots_all, filename_rs)